# RabbitMQ入门

> 参考：
> [RabbitMQ官网](https://www.rabbitmq.com/getstarted.html)
> <https://javaguide.cn/high-performance/message-queue/rabbitmq-intro.html#%E4%B8%80-rabbitmq-%E4%BB%8B%E7%BB%8D>

## 安装

1、安装 [rabbitmq](https://www.rabbitmq.com/download.html)，配置 RabbitMQ Server 的环境变量

2、启动管理功能

```powershell
 rabbitmq-plugins enable rabbitmq_management
```

## 概述

> 软件组件的解耦是软件设计的重要组成部分之一。实现软件解耦的一种方法是使用消息传递系统，它提供组件(服务)之间的异步通信方式。

`RabbitMQ `是一个消息代理，它实现了高级消息队列协议(`AMQP`) ，为主流编程语言提供客户端库。

除了用于解耦软件组件之外，`RabbitMQ `还可用于:

*   执行后台操作

*   执行异步操作

## 信息传递模式

简而言之，有两种与消息传递系统交互的应用程序: 生产者和消费者。生产者是向代理发送(发布)消息的人，消费者是从代理接收消息的人。通常，这些程序(软件组件)在不同的机器上运行，`RabbitMQ `作为它们之间的通信中间件。

## RabbitMQ核心概念

![图1-RabbitMQ 的整体模型架构](https://s2.loli.net/2022/07/13/ioZBwL7raeGmEth.png)

![](https://raw.githubusercontent.com/zoooooway/picgo/master/202304121524262.png)

### Producer(生产者) 和 Consumer(消费者)

*   **Producer(生产者)** :生产消息的一方。生产者声明交换器，并且将消息推送给它。交换器会负责把收到的消息推送到该消息应该去往的队列中去。

*   **Consumer(消费者)** :消费消息的一方。消费者通过队列来获取消息，队列由消费者声明并将其绑定到某个交换器上。

举个栗子，你去吃饭，有好几个窗口分别提供不同类型的食物（消息），你想吃哪种食物就需要端个盘子（队列）去那个窗口去排队等阿姨（交换器）给你打菜。有个很不文明的举动就是你一个人排好几个窗口，这样你就可以同时吃到这几种食物。阿姨（交换器）需要等后厨（生产者）来给他做好菜，后厨会选一个或者多个阿姨和他配合，等他做好菜了就把菜递给他，阿姨知道这个菜是送到哪个窗口（队列）的。

消息一般由两部分组成：**消息头**（或者说是标签 Label）和 **消息体**。消息体也可以称为 `payLoad `,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 `routing-key`（路由键）、`priority`（相对于其他消息的优先权）、`delivery-mode`（指出该消息可能需要持久性存储）等。生产者把消息交由 `RabbitMQ `后，`RabbitMQ `会根据消息头把消息发送给感兴趣的` Consumer`。

### Queue(消息队列)

`Queue` 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。

`RabbitMQ `中消息只能存储在 **队列** 中。 `RabbitMQ `的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。

**多个消费者可以订阅同一个队列**，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。

`RabbitMQ `不支持队列层面的广播消费，如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。

#### 消息确认

`RabbitMQ`支持消息消费后的自动确认，即一旦 `RabbitMQ` 将消息传递给消费者，它会立即将其标记为删除。此时，如果消费者异常，那么该消息及传递给该消费者的其他未处理完成的消息都会丢失。

为了确保消息永远不会丢失，`RabbitMQ` 支持消息手动确认。消费者需要发送一个确认消息，告诉 `RabbitMQ` 某条消息已被接收、处理，并且 `RabbitMQ` 可以自由删除该消息。

> 默认情况下打开手动消息确认

如果消费者异常(其通道关闭，连接关闭，或 `TCP` 连接丢失)而没有发送一个 `ack`，`RabbitMQ` 将理解消息没有被完全处理，并将重新排队。如果同时还有其他消费者在线，它就会迅速将其重新发送给另一个消费者。这样你可以确保没有信息丢失，即使消费者偶尔异常。

> 对使用者传递确认执行超时(默认为30分钟)

#### 信息持久性

如果 `RabbitMQ` 服务器停止，我们的消息会丢失。

当 `RabbitMQ` 退出或崩溃时，它会丢失队列和及其中的所有消息，除非您告诉它不要这样做。要确保消息不会丢失，需要做两件事: **我们需要将队列和消息都标记为持久消息**。

首先，我们需要确保队列在 `RabbitMQ` 节点重新启动后仍然存在。为了做到这一点，我们需要声明它是持久的:

```java
boolean durable = true;
// 第二个参数代表此队列是否应该持久化
channel.queueDeclare("hello", durable, false, false, null);
```

> 注意：已经声明了的队列不能通过再次声明队列来改变队列是否持久化的属性。例如已经声明了hello队列并且未开启持久化，再次执行上面代码的操作则会报错。

此时，我们确信即使 `RabbitMQ` 重新启动，声明了持久化的队列也不会丢失。现在，还需要处理消息丢失的问题，我们需要将 `MessageProperties` (实现 `BasicProperties` )设置为值 `PERSISTENT _ TEXT _ PLAIN`，从而将消息标记为持久消息。

```java
import com.rabbitmq.client.MessageProperties;

channel.basicPublish("", "task_queue",
            MessageProperties.PERSISTENT_TEXT_PLAIN,
            message.getBytes());
```

> 将消息标记为持久性并不能完全保证消息不会丢失。虽然它告诉 `RabbitMQ` 将消息保存到磁盘，但是当 `RabbitMQ` 接受了一条消息并且还没有保存它时，仍然有一个很短的时间窗口。另外，`RabbitMQ` 不会对每条消息执行 `fsync(2)`——它可能只是保存到缓存中，而不是真正写入磁盘。持久性保证并不强大，但对于我们的简单任务队列来说已经足够了。如果你需要一个更强有力的保证，那么你可以使用[Publisher Confirms](https://www.rabbitmq.com/confirms.html#publisher-confirms) (一种类似上述消费者确认的机制，只不过对象为生产者和代理)。

#### 调度公平性

假设你有一个消息队列，位于奇数位的消息所需耗时都远大于偶数位的，同时你有两个消费者，在默认情况下，其中一个消费者将会一直忙碌，而另外一个则较为空闲。这是因为 `RabbitMQ` 只在消息进入队列时发送消息。它没有考虑消费者未确认的信息的数量。它只是盲目地将第 n 条消息发送给第 n 个消费者。

为了避免这种情况，我们可以使用设置`prefetchCount = 1`的 `basicQos `方法。这告诉 `RabbitMQ` 一次不要给一个工作者发送多条消息。或者，换句话说，在工作线程处理并确认前一个消息之前，不要将新消息发送给工作线程。相反，它会将其分派给下一个不再忙碌的工作者。

```java
// prefetchCount - 服务器将传递的最大消息数，如果无限制则为 0
int prefetchCount = 1;
channel.basicQos(prefetchCount);
```

> 如果所有的消费者都很忙，你的队列就会满。你需要密切关注这一点，也许需要增加更多的消费者，或者采取其他策略。

### Broker（消息中间件的服务节点）

对于 `RabbitMQ`来说，一个 `RabbitMQ Broker` 可以简单地看作一个 `RabbitMQ`服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 `RabbitMQ Broker` 看作一台 `RabbitMQ` 服务器。

下图展示了生产者将消息存入 `RabbitMQ Broker`,以及消费者从Broker中消费数据的整个流程:

![消息队列的运转过程](https://s2.loli.net/2022/07/13/PCUTeK1WkysD8bE.png)


## 发布/订阅

> 对于工作队列来说，其背后的假设是，每个任务只交付给一个消费者。在本部分中，我们将做一些完全不同的事情——我们将向多个消费者传递消息。这种模式称为“**发布/订阅**”。

以下内容建立在这样一个需求上： 我们将构建一个简单的日志记录系统。它将由多个程序组成——第一个程序将发出日志消息，余下程序将接收和打印日志消息。这意味着现在有个一个生产者即一个日志来源程序，但同时有多个消费者即多个日志接收程序来实时打印或计算这些日志。如何让多个消费者都获取到消息？

首先让我们来了解一下RabbitMQ中的一些基本概念。

### 交换器

RabbitMQ 中消息传递模型的核心思想是，**生产者永远不会直接向队列发送任何消息**。实际上，生产者常常根本不知道消息是否会被传递到任何队列。

相反，生产者只能将消息发送到`Exchange`(交换器)。

对交换器来说，一方面，它接收来自生产者的消息，另一方面，它将这些消息推送到队列。交换器必须确切地知道如何处理它接收到的消息。它应该被追加到特定的队列中吗？它应该被追加到许多队列中吗？还是应该被丢弃。其规则由交换器类型定义。

> 查看服务器上的交换器
>
> ```shell
> sudo rabbitmqctl list_exchanges
> ```

#### Exchange Types(交换器类型)

`RabbitMQ `常用的 `Exchange Type` 有 `fanout`、`direct`、`topic` 这三种。

*   **fanout**

    fanout 类型的`Exchange`路由规则非常简单，它会把所有发送到该`Exchange`的消息路由到所有与它绑定的`Queue`中，不需要做任何判断操作，所以 `fanout` 类型是所有的交换机类型里面速度最快的。`fanout` 类型常用来广播消息。

*   **direct**

    `direct` 类型的`Exchange`路由规则也很简单，它会把消息路由到那些 `Bindingkey` 与 `RoutingKey` 完全匹配的 `Queue` 中。

    `direct` 是默认的交换器类型。

    `direct` 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。

*   **topic**

    前面讲到`direct`类型的交换器路由规则是完全匹配 `Bindingkey` 和 `RoutingKey` ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。`topic`类型的交换器在匹配规则上进行了扩展，它与 `direct` 类型的交换器相似，也是将消息路由到 `Bindingkey` 和 `RoutingKey` 相匹配的队列中，但这里的匹配规则有些不同，它约定：

    *   `RoutingKey` 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;

    *   `Bindingkey` 和 `RoutingKey` 一样也是点号“．”分隔的字符串；

    *   `Bindingkey` 中可以存在两种特殊字符串“\*”和“#”，用于做模糊匹配，其中“\*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。


但在此我们先关注`fanout`。

`fanout`将接收到的所有消息广播到它知道的所有队列。这意味着，只要有队列和该交换器**绑定**了，那么发送到该交换器的所有消息都会分别分发给这些队列。

### 绑定

交换器和队列之间的关系称为绑定。绑定非常简单：

```java
channel.queueBind(queueName, "logs", "BingingKey");
```

`RabbitMQ `中通过 **Binding(绑定)** 将 `Exchange` 与 `Queue` 关联起来。

生产者将消息发送给交换器时，需要一个`RoutingKey`,当 `Bindingkey` 和 `RoutingKey` 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 `Bindingkey`。

OK，现在让我们理清楚一下流程。如果你需要广播一个消息，在这里以上述的日志系统为例，那么：

*   首先你需要声明一个交换器、N个队列，N应该是需要接收日志的程序数量

*   将这N个队列和交换器进行绑定

*   将这N个队列与它们对应的消费者即日志接收程序绑定

*   推送消息，并指定交换器的名称

此时，每推送一条消息，N个队列中都会存在该消息，不同的日志接收程序就都能获取到消息了。

### 临时队列

当希望在生产者和消费者之间共享队列时，为队列命名非常重要。换句话说，我们希望不同的消费者都去同一个队列中获取数据时，命名就非常有用，因为这样我们可以通过名称来确定目标队列。

但对应这里的日志系统可能就并不需要了。一方面，这里的消费者只需要关心最新的日志，因此对旧数据并没有要求，另一方面，只需要在消费者需要消费日志时进行推送，而不是一开始直接创建多个队列然后填充数据，这样消费者消费时可能队列中已经存在过时的消息了。

因此，每当我们连接到 `RabbitMQ `我们需要一个新的，空的队列。为此，我们可以创建一个具有随机名称的队列，或者，更好的方法是——让服务器为我们选择一个随机队列名称。

当我们没有为`queueDeclare ()`提供任何参数时，会创建一个**非持久的、独占的自动删除队列**，并生成一个**随机名称**。

结合上面的内容，实现日志系统关键的代码类似于：
生产者：
```java
// 声明一个名叫logs的fanout类型的交换器
channel.exchangeDeclare("logs", "fanout");
// 推送消息，此时logs交换器会负责将该消息传递到所绑定的队列
// 第一个参数是交换器名，第二个参数是绑定键（此例中值被忽略），第三个参数是消息的属性包括消息类型
channel.basicPublish( "logs", "", null, message.getBytes("UTF-8"));
```
消费者：
```java
// 不指定名称，创建一个临时队列，并获取生成的随机队列名
String queueName = channel.queueDeclare().getQueue();
// 将队列和交换器进行绑定，第三个参数表示绑定键
channel.queueBind(queueName, "logs", "");
// 监听队列来消费消息 deliverCallback 是收到消息应该执行的处理逻辑
// true 表示服务器应该在消息发送后得到确认
channel.basicConsume(queueName, true, deliverCallback, consumerTag -> { });
```

> 对于其他交换器来说，推送信息后交换器会根据消息的路由键匹配。但对于`fanout`类型的交换器来说，会自动忽略消息的路由键，将消息推送到所有绑定到该交换器的队列中。

## 路由

> 进一步思考上述的日志系统，如果现在我们需要增加一个功能，它需要实现：某些日志接收程序只接受指定日志级别的日志消息，例如：warning，error等。这时，应该如何扩展？

`fanout`类型的交换器不能实现根据某一条件来对消息进行区别推送，因此，这里，我们需要使用其他类型的交换器。但在此之前，先让我们了解一下，`routing key`(路由键)的概念。

在前面的示例中，我们已经创建了绑定:

```java
channel.queueBind(queueName, EXCHANGE_NAME, "");
```

绑定是交换器和队列之间的关系。这可以简单地理解为: 队列对来自此交换器的消息感兴趣。

执行绑定时可以采用额外的 `routing key` 参数。为了避免与 `channel.basicPublish`参数混淆，我们将其称为**绑定键**。这就是我们如何用一个键创建一个绑定:

```java
channel.queueBind(queueName, EXCHANGE_NAME, "black");
```

绑定键的含义取决于`Exchange Types`（交换器类型）。我们以前使用的`fanout`交换器只是忽略了它的作用。

接下来让我们看如何使用另一种交换器类型——`direct`来完成指定消息分发。

`direct`背后的路由算法很简单——将消息传递到其绑定键与消息的路由键这两者**完全匹配**的队列。

![img](https://s2.loli.net/2022/07/15/Zdtn1i7DsLHx5Kh.png)

上图是一个简单的例子来说明`direct`执行逻辑。p代表生产者，生产者将消息推送给`direct`类型的交换器，该交换器和Q1进行了绑定，绑定键为orange。同时该交换器还绑定了Q2，绑定键为black和green。此时生产者推送消息中的路由键就决定了该消息的归属队列，假设该消息携带的路由键为orange，则消息被推送到Q1，同理black和green被推送到Q2。假设携带的路由键为white，则该消息会因为没有匹配的队列而被丢弃。

上图还表明，**一个交换器和一个队列之间可以存在多个绑定键**。

![img](https://s2.loli.net/2022/07/15/Mgd7VNCyvhfTzHw.png)

同时，多重绑定是允许的。如上图，**多个队列可以使用相同的绑定键来和同一交换器进行绑定**。此时，对于该绑定键的消息来说，就类似于`fanout`类型的交换器进行广播的效果。

## Topic

上述通过`direct`来进行消息路由虽然可以满足日志系统的要求，但是仍然有很大的局限性——它不能基于多个标准进行路由。

基于上述日志系统，考虑如下的新需求：现在我们不仅希望订阅基于日志等级的日志消息，还希望订阅基于发出日志的来源的日志。举个栗子，消费者A只关心登录模块的所有日志和定时任务模块中的error级别日志。这时，通过`direct`交换器就需要比较繁琐的操作——构建多个绑定键类似：auth.info、auth.debug、...、task.error，然后将这些绑定键和某个队列进行绑定，消费者A再去消费这个队列。

上述的一大问题在与配置的繁琐，有多少种类的消息就要绑定多少次，而且每次改动十分麻烦，得改很多地方。而`topic`类型的交换器可以帮我们解决这一问题。

发送到`topic`交换器的消息不能是随意的路由键——它有固定的格式：必须是**由点分隔的单词列表**。 这些单词可以是任何东西，但是通常它们指定一些与消息相关的特性。 几个有效的路由键示例: “ stock.usd.nyse”、“ nyse.vmw”、“ quick.orange.rabbit”。 路由键中可以包含任意多的单词，最多不超过255个字节。

绑定键也必须采用相同的形式。 `topic`交换器背后的逻辑类似于`direct`交换器的逻辑——使用特定路由键发送的消息将传递给使用匹配的绑定键绑定的所有队列。 然而，对于绑定键有两个重要的特殊情况:

*   \* **可以代替一个单词**（注意，只能代表一个）。

*   \#  **可以代替零个或多个单词**。

简而言之，这有点类似正则匹配的路由。来看下面的例子：

![img](https://s2.loli.net/2022/07/15/6QRHJdNtDBx5feS.png)

在这个例子中，我们将发送所有描述动物的消息。消息体为："<速度>.<颜色>.<物种>"。

那么上面的例子可以解释为：

*   Q1对所有橙色的动物都很感兴趣

*   Q2想获取关于兔子的一切，还有关于懒惰的动物的一切

这个示例很简单，不多做解释。值得注意的有以下几点：

*   多次匹配同一队列的消息**不会重复发送**。比如：消息路由键为lazy.red.rabbit，这时对Q2而言，该消息同时成功匹配了两个绑定键。但Q2只会收到一次该消息。

*   没有匹配成功的消息将被丢弃。

*   假设消息没有遵守约定，携带的路由键是只有一个或四个词的键，比如“ orange”或者“ quick.orange.male.rabbit”。则这些消息不会匹配任何绑定，会丢失，因为 **“\*”** 只能代表一个单词。但 “**#**” 可以代表零个或多个单词，因此假设携带路由键形如：lazy.orange.male.rabbit 或者 lazy.red，那么消息仍然会传递到Q2。

> `topic`交换器很强大，它可以具备其他交换器的同样功能。
>
> 当一个队列用 “**#**” 绑定键绑定时，它将接收所有消息。这和`fanout`交换器的功能相同。
>
> 当绑定中不使用特殊字符 **“\*”** 和 **“#”** 时，效果和`direct`交换器的功能相同。

## RPC

## Publisher Confirms


## 与 Kafka 对比
| 特性     | Apache Kafka                                                                | RabbitMQ                                                                                 |
| -------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| 架构     | Kafka 使用分区日志模型，结合了消息收发队列和发送-订阅方法。                 | RabbitMQ 使用消息收发队列。                                                              |
| 可扩展性 | Kafka 允许跨不同服务器分发分区，因此具有可扩展性。                          | 增加队列中的使用器数量可以将处理扩展到竞争使用器。                                       |
| 消息保留 | 基于策略，例如消息可以存储一天。用户可以配置此保留窗口。                    | 基于确认，表示消息在使用后被删除。                                                       |
| 多使用器 | 多个使用器可以订阅相同主题，因为 Kafka 允许将同一条消息重放指定的时间长度。 | 多个使用器无法全部接收同一条消息，因为消息在使用后将被删除。                             |
| 复制     | 自动复制主题，但是用户可以手动将主题配置为不复制。                          | 消息不会自动复制，但是用户可以手动将其配置为复制。                                       |
| 消息排序 | 由于采用了分区日志架构，每个使用器按顺序收到信息。                          | 消息按照其到达队列的顺序传送给使用器。如果有竞争使用器，每个使用器都将处理该消息的子集。 |
| 协议     | Kafka 通过 TCP 使用二进制协议。                                             | 高级消息收发队列协议 (AMQP) 及通过插件获得的支持：MQTT、STOMP。                          |


**生产者发送消息的流程:**
1. 生产者连接`RabbitMQ`，建立TCP连接(`Connection`)，开启信道(`Channel`)
2. 生产者声明一个`Exchange`（交换器），并设置相关属性，比如交换器类型、是否持久化等
3. 生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等
4. 生产者通过`bindingKey`（绑定Key）将交换器和队列绑定(`binding`)起来
5. 生产者发送消息至`RabbitMQ Broker`，其中包含`routingKey`(路由键)、交换器等信息
6. 相应的交换器根据接收到的`routingKey`查找相匹配的队列
7. 如果找到，则将从生产者发送过来的消息存入相应的队列中
8. 如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者
9. 关闭信道
10. 关闭连接

**消费者接收消息的过程:**
1. 消费者连接到`RabbitMQ Broker`，建立一个连接(`Connection`)，开启一个信道(`Channel`)
2. 消费者向`RabbitMQ Broker`请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作
3. 等待`RabbitMQ Broker`回应并投递相应队列中的消息，消费者接收消息
4. 消费者确认(`ACK`)接收到的消息
5. `RabbitMQ`从队列中删除相应己经被确认的消息
6. 关闭信道
7. 关闭连接

## 一些特性
### 优先级队列
> https://www.rabbitmq.com/priority.html

`RabbitMQ`支持使用优先级队列，顾名思义，此队列中优先级高的消息具备优先被消费的特权。

`RabbitMQ`优先级队列注意点：
* 只有当消费者不足，不能及时进行消费的情况下，优先级队列才会生效。
  > 之所以会这样是因为，如果消费者足够，导致消息不会在队列排队就直接被消费了，那么也不存在优先这个说法了。
* `RabbitMQ3.5`版本以后才支持优先级队列。

### TTL
> https://www.rabbitmq.com/ttl.html

`RabbitMQ`支持对消息设置消息过期时间（TTL）。

当某个消息在队列留存的时间超过了配置的TTL值时，我们说该消息 *已死* 。

服务器会保证 *已死* 的消息将不会在任何 `basic.get-ok` 或 `basic.deliver` 方法中被包含。更进一步的，服务器将努力在 `TTL` 到期或到期后的短时间内处理掉该消息。 

有两种方式可以进行设置：
* 通过队列属性设置，队列中所有消息都有相同的过期时间。
  如果通过设置队列属性的方法设置消息的 `TTL` ，**一旦消息过期，就会从队列中抹去**。
* 对每条消息单独设置过期时间，每条消息的 `TTL` 可以不同。如果两种方法一起使用，则消息的 `TTL` 以两者之间较小的那个数值为准。
  如果每条消息单独设置过期时间，即使消息过期，也不会马上从队列中删除，因为每条消息**是否过期是在消息投递到消费者之前才进行检查**。

> 如果已为队列配置了死信交换，则队列将过期消息传输到死信交换器。然后，死信交换器将消息路由到死信队列。您可以获取死信队列中的消息。(详见 **Dead Letter Exchanges** 一节)

### Dead Letter Exchanges (死信交换器)
> https://www.rabbitmq.com/dlx.html
> https://www.tizi365.com/topic/37.html

![](https://raw.githubusercontent.com/zoooooway/picgo/nom/202304141331245.png)
在RabbitMQ中，当消息在一个队列中变成一个死信（消费者无法处理的消息）之后，它将被重新投递到另一个交换机上，这个交换机我们就叫做死信交换机，死信交换机将死信投递到一个队列上就是**死信队列**。

下面是死信产生的条件：
* 消息被消费者手动拒绝(basic.reject / basic.nack)，并且`requeue = false`
* 消息 `TTL` 过期
* 队列达到最大长度

死信队列处理步骤
1. 定义一个死信交换机（别被名字误导，就是一个普通的交换机，只不过用在了死信处理场景，才叫这个名字）
2. 定义一个队列绑定死信交换机（这个队列就叫死信队列，也是一个普通队列）
3. 定义死信消费者，消费死信队列（别被名字误导，这也是普通的消费者）
4. 将死信交换机绑定到指定队列上（哪个队列需要处理死信就绑定谁）

### 延迟消息
> https://www.tizi365.com/topic/38.html

`RabbitMQ` 可以实现延迟消息的传递，消息将在延迟指定毫秒后传递到相应的队列。
`RabbitMQ` 原生不支持延迟消息，目前主要通过死信交换机 + 消息 `TTL` 方案或者 *rabbitmq-delayed-message-exchange* 插件实现。

#### 死信交换机 + 消息TTL方案实现延迟队列
这个方案核心思想就是，创建一个没有消费者的队列，借助消息 `TTL` ，当一条消息过期后会成为死信，这条死信消息会投递到死信交换机，死信交换机将消息发给死信队列，我们只要消费死信队列即可。

在这个方案中，消息过期时间就是消息延迟时间，例如： 消息 `TTL` = 30秒，因为这个队列没有消费者，消息 30 秒后过期，这条消息就变成死信，会被死信队列处理。






















