# 垃圾回收器
> Note: 本文的内容都是来源于文中链接的文章，结合自己的理解所写，仅作自己参考使用。英语能力有限，有些概念可能理解有误，请勿轻信。

目前工作中大多使用 Java 8 来进行开发，因此主要针对 Java 8 进行说明。
其次 Java 22 目前是最新的版本，因此也对该版本的 `GC` 来进行简单说明。

## 调优目标

一般而言，JVM 的调优都是为了两个目标：
* 吞吐量：吞吐量目标是根据垃圾回收所花费的时间来衡量的，垃圾回收之外所花费的时间就是应用程序时间。应用执行的时间越多，吞吐量就越大。
* 暂停时间：暂停时间是垃圾收集器停止应用程序并回收不再使用的空间的持续时间。最大暂停时间目标的目的是限制这些暂停中最长的时间。

这两个目标常常会相互竞争：
* 假设指定了最大暂停时间为 xxx 毫秒，为了满足目标，垃圾回收器会调整 Java 堆大小以及与垃圾回收相关的其他参数，以尝试使垃圾回收的暂停时间小于 xxx 毫秒。这些调整可能会导致垃圾回收更频繁地发生，从而降低应用程序的整体吞吐量。
* 为了增加吞吐量，我们需要减少垃圾回收的时间。最简单的方式就是增加堆的大小，堆越大，填满分代的时间就越久，触发垃圾回收的次数就会越少。如果堆增长到其最大大小并且未满足吞吐量目标，则最大堆大小对于吞吐量目标而言太小。另一方面，增大了堆的大小，那么相应的，垃圾回收的暂停时间也会增加（因为回收的东西更多了），因此暂停时间目标又可能无法满足。


## Server-class Machines

*Server-class Machines*（服务器级计算机）指满足以下特征的计算机：
* 2 个或更多物理处理器
* 在 Java 8 版本需要大于 2 GB 物理内存，在 Java 22 版本需要大于 1792 MB 物理内存

在服务器级计算机上，默认选择以下选项：
* 服务器级计算机默认使用的收集器根据 Java 版本的不同而不同：
  * 在 Java 8 版本，默认使用吞吐量垃圾收集器，也就是 `Parallel` 收集器
  * 在 Java 22 版本，默认使用 `G1` 收集器
* 初始堆大小为物理内存的 1/64，最多 1 GB
* 最大堆大小为物理内存的 1/4，最多 1 GB
  

## JAVA 8
这部分介绍仅针对 Java 8 而言，后续的版本其特性可能有所变动.

> 调优：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/
> basic: https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html

### Serial Garbage Collector

在性能较差的计算机上，串行收集器是默认的 `GC`。

串行收集器使用单个线程来执行垃圾回收。进行回收时，应用程序将会暂停。

### Parallel Garbage Collector

在 *Server-class Machines* 上，`Parallel` 收集器 是 Java 8 默认的垃圾回收器。

并行收集器与串行收集器的主要区别在于使用多个线程来加速垃圾回收。进行回收时，应用程序将会暂停。
并行收集器也被称为吞吐量收集器（*Throughput garbage collector*）。
并行收集器默认会启用并行压缩，会执行整个堆压缩。

通过命令行选项 `-XX:+UseParallelGC` 启用并行收集器。


### Mostly Concurrent Collector
串行收集器和并行收集器在执行垃圾回收时，应用程序将会暂停，而并发收集器在应用程序运行时也能执行垃圾回收过程中的大部分（Mostly）操作。

并发收集器会使用应用程序的处理器资源来缩短主要收集的暂停时间。最明显的开销是在回收器的并发操作期间使用一个或多个处理器资源（此时应用程序可能仍在运行，因此应用程序的吞吐量将受到影响）。
以下两种 `CMS` 与 `G1` 都属于并发收集器，但这两者的实现有很大的区别。

#### CMS Garbage Collector
> https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector

`CMS` 使用标记清除算法来执行垃圾回收，不会执行压缩。

以下列举 `CMS` 执行回收的两个主要特性:

##### 暂停  
`CMS` 收集器在并发收集周期内暂停应用程序两次:
1. 第一次暂停发生在将对象标记为活动对象时。第一次停顿称为 *initial mark pause* （初始标记停顿）。
2. 第二次暂停出现在并发跟踪阶段（见下文）的末尾，并且发现了并发跟踪遗漏的对象。这些对象是在 `CMS` 收集器完成对对象的跟踪之后，由于应用程序线程对对象的引用进行了更新，因此产生了一些对象现在应当被标记但却没有被标记的的情况。这第二次停顿称为 *remark pause* （再标记停顿）。 

年轻代收集和老年代收集的暂停是独立发生的。它们不会同时发生，但可能快速连续发生。

##### 并发阶段
应用程序在并发阶段不会暂停。

* ###### concurrent tracing phase
可访问对象图的并发跟踪发生在 *initial mark pause* 和 *remark pause* 之间。
在此并发跟踪阶段，一个或多个并发垃圾收集器线程可能正在使用本来应用程序可以使用的处理器资源。因此，即使应用程序线程没有暂停，应用程序在这个阶段和其他并发阶段的吞吐量也会相应下降。

* ###### concurrent sweeping phase 
在 *remark pause* 之后，并发扫描阶段收集标识为不可达的对象（垃圾）。一旦收集周期完成，`CMS` 收集器将等待，几乎不消耗任何计算资源，直到下一个收集周期开始。

值得注意的是：`CMS` 并不会压缩空间，

#### G1 Garbage Collector
> https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html
> https://www.oracle.com/java/technologies/javase/hotspot-garbage-collection.html
> https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html

`G1`（Garbage First）收集器适用于具有大内存的多核处理器计算机，该收集器延迟低，并且能压缩空间减少碎片化。

与 `CMS` 一样，`G1` 也会在应用程序运行时执行一部分的回收操作。

`G1` 将堆划分为一组大小不等的堆区域，每个区域都是一个连续的虚拟内存范围，因此内存不能太小。

`G1` 在并发全局标记阶段确定整个堆中对象的活跃度。标记阶段完成后，`G1` 就知道了哪些区域的可回收的垃圾会更多。`G1` 将会集中在这些可能充满可回收对象（即垃圾）的堆区域进行收集和压缩活动，这就是为什么被称为垃圾优先的原因。


##### 分代
从逻辑上讲，`G1`是存在世代的概念。

其中一组空区域将会被指定为逻辑上的年轻代。当年轻代满员时，这组区域将被执行垃圾收集也就是 `young collection` (有时也叫 `young gc`)。
在某些情况下，年轻代之外的区域（老年代）可以同时执行垃圾收集。这被称为 *mixed collection* （`mixed gc`）。

`G1` 将活动对象从堆的一个或多个区域复制到堆上选定的、最初为空的区域，根据存活对象的年龄，可以将该对象复制到幸存区，并在此过程中释放内存。这些操作被称为 `evacuation`（疏散）。
疏散在多处理器上并行执行，以减少暂停时间并提高吞吐量。注意并不是并发，疏散是 `STW`（stop-the-world）操作。

##### 暂停
`G1` 会暂停应用程序以将活动对象复制到新区域。

这些暂停可以是仅收集年轻代的 `young gc` 暂停，也可以是年轻代和老年代的 `mixed gc` 暂停。
与 `CMS` 一样，在应用程序停止时，有一个*remark pause* 以完成标记。 `G1` 将 *initial mark* 作为疏散暂停的一部分进行。
`G1` 在收集的末尾有一个清理阶段，该阶段部分操作是 `STW`，部分操作是并发的。清理阶段的 `STW` 部分标识空区域，并确定作为下一个收集候选项的区域。

`G1` 使用暂停预测模型来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数量。

`G1` 相对于 `CMS` 有几个好处：
1. `G1` 执行垃圾回收会进行压缩减少碎片化，而 `CMS` 不会。
2. `G1` 提供比 `CMS` 收集器更可预测的垃圾回收暂停时间，并允许用户指定所需的暂停时间目标。

## JAVA 22

### Z Garbage Collector
> https://docs.oracle.com/en/java/javase/22/gctuning/z-garbage-collector.html#GUID-FD855EE7-9ED3-46BF-8EA5-A73EB5096DDB

`ZGC` 是一种可伸缩的低延迟垃圾收集器。 
`ZGC` 同时执行所有昂贵的工作，而不会停止应用程序线程的执行超过一毫秒的时间。它适用于需要低延迟的应用程序。暂停时间与正在使用的堆大小无关。`ZGC` 可以很好地处理从几百兆字节到*16TB* 的堆大小。